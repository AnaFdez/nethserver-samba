#!/usr/bin/perl

#
# Copyright (C) 2013 Nethesis S.r.l.
# http://www.nethesis.it - support@nethesis.it
# 
# This script is part of NethServer.
# 
# NethServer is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License,
# or any later version.
# 
# NethServer is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with NethServer.  If not, see <http://www.gnu.org/licenses/>.
#

use strict;
use NethServer::Directory;
use esmith::AccountsDB;
use esmith::ConfigDB;
use esmith::event;
use esmith::util;
use File::Temp;
use File::Copy;
use User::grent;
use Net::LDAP::LDIF;
use Carp;
use Data::Dumper;

sub importDomainSid($$);
sub parseSmbPasswd($);
sub parseGroupMap($$);


my $event = shift;
my $sourceDir = shift;
my $esmithDbDir = '/home/e-smith/db';
my $errors = 0;
my $ldapResponse;

if( ! $event ) {
    die("Missing event argument!\n");
}

if( ! $sourceDir ) {
    die("Missing sourceDir argument!\n");
}

my $srcConfigDb = esmith::ConfigDB->open_ro(join('', $sourceDir, $esmithDbDir, '/configuration')) or die("Could not open source configuration database in $sourceDir \n");
my $dstConfigDb = esmith::ConfigDB->open('configuration') or die("Could not open configuration account db\n");

my $srcAccountsDb = esmith::AccountsDB->open_ro(join('', $sourceDir, $esmithDbDir, '/accounts')) or die("Could not open source accounts database in $sourceDir \n");
my $dstAccountsDb = esmith::AccountsDB->open('accounts') or die("Could not open destination account db\n");

my $ldap = NethServer::Directory->new() or die("Could not connect LDAP server\n");
my $LdapInternalSuffix = NethServer::Directory::getInternalSuffix();

my $domainName = qx(/usr/bin/testparm -s ${sourceDir}/etc/samba/smb.conf --parameter-name='workgroup' 2>/dev/null);
my $serverRole = $srcConfigDb->get_prop('smb', 'ServerRole') || 'WS';

chomp ($domainName);

warn "[INFO] importing domain $domainName (role $serverRole)\n";

# Copy some smb props in dst db:
$dstConfigDb->get('smb')->merge_props(
    ServerRole => $serverRole,
    Workgroup => uc($domainName),
    RoamingProfiles => $srcConfigDb->get_prop('smb', 'RoamingProfiles') || 'no',
    NetbiosAliasList => uc($srcConfigDb->get_value('SystemName')),
);
$dstConfigDb->reload();

# Change smb Workgroup and role according to source configuration:
if( ! esmith::event::event_signal('nethserver-samba-save')) {
    die("[ERROR] nethserver-samba-save event failed\n");
}

if($serverRole ne 'PDC') {
    warn "[INFO] exiting because server role is set to $serverRole\n";
    exit(0);
}

# Clean previous LDAP sambaDomain objects:
$ldap->delete(sprintf('sambaDomainName=%s,%s', $domainName, $LdapInternalSuffix));
$ldap->delete(sprintf('sambaDomainName=%s,%s', uc($dstConfigDb->get_value('SystemName')), $LdapInternalSuffix));

# Import the domain SID entry, from secrets.tdb
my $domainSid = importDomainSid($domainName, $sourceDir . '/etc/samba/secrets.tdb') or die("[ERROR] Could not obtain domain SID\n");
warn "[INFO] importing $domainName SID: $domainSid\n";

#
# re-expand /etc/hosts to include our NetbiosAliasList
#
system(qw(/sbin/e-smith/expand-template /etc/hosts));

# set the new domain SID also as local SID. Domain and local SIDs
# seems to be equal on fresh samba installations...
system('/usr/bin/net', 'setlocalsid', $domainSid);
if( $? != 0) {
    warn("Could not set local SID to $domainSid\n");
    $errors++;
}

# This initializes also LDAP db:
system('/usr/bin/net getdomainsid &>/dev/null');


#
# migrate machine accounts
#
foreach ($srcAccountsDb->get_all_by_prop(type => 'machine')) {
    $dstAccountsDb->set_prop($_->key, 'Uid', $_->prop('Uid'), type => 'machine');

    my $secret = esmith::util::genRandomHash();

    open(PH, '|-', '/usr/bin/pdbedit -t -a -m -u ' . $_->key . ' >/dev/null 2>&1');
    print PH $secret . "\n" . $secret . "\n";
    if( ! close(PH)) {
	warn "[ERROR] failed to add machine account " . $_->key . " in SAM db\n";
	$errors ++;
    }
}

my %userDb = parseSmbPasswd($sourceDir . '/etc/samba/smbpasswd');
my %groupRid = parseGroupMap($domainSid, $sourceDir . '/var/lib/samba/group_mapping.ldb');


# Well known RIDs (see also nethserver-samba-sam-conf action):
$groupRid{domadmins} = '512';
$groupRid{domusers} = '513';
$groupRid{domguests} = '514';
$groupRid{domcomputers} = '515';


#
# sync user and machine SIDs and passwords
#
foreach ($dstAccountsDb->get_all_by_prop(type => 'machine'), 
	 $dstAccountsDb->get_all_by_prop(type => 'user')) {

    my $uid = $_->key;
    my $userDn = sprintf('uid=%s,ou=People,%s', $uid, $LdapInternalSuffix);

    my $attrs = {};

    if($userDb{$uid}) {
	$attrs->{sambaSID} = $domainSid . '-' . $userDb{$uid}->{rid};
	$attrs->{sambaNTPassword} = $userDb{$uid}->{password};
    } else {
	warn "[WARNING] smbpasswd account not found: " . $uid;
    }

    $ldapResponse = $ldap->modify($userDn, replace => $attrs);
    if($ldapResponse->is_error) {
	warn "[ERROR] failed to update $userDn SAM entry\n";
	$errors++
    }

    # update also user primary group (users only):
    if($_->prop('type') eq 'user') {
	my $groupDn = sprintf('cn=%s,ou=Groups,%s', $uid, $LdapInternalSuffix);
	$ldapResponse = $ldap->modify($groupDn, replace => {
	    $groupRid{$uid} ? ('sambaSID', $domainSid . '-' . $groupRid{$uid}) : ()
				      });
	if($ldapResponse->is_error) {
	    warn "[ERROR] failed to update $groupDn SAM entry\n";
	    $errors++
	}
    }

}

#
# migrate groups SIDs
#
foreach my $gid ( keys %{{
    (map { $_->key => 1 } $dstAccountsDb->get_all_by_prop(type => 'group')), 
    qw(
      domadmins  1
      domusers   1
      domguests  1
    )}} ) {

    my $groupDn = sprintf('cn=%s,ou=Groups,%s', $gid, $LdapInternalSuffix);

    my $attrs = {};

    if($groupRid{$gid}) {
	$attrs->{sambaSID} = $domainSid . '-' . $groupRid{$gid};
    } else {
	warn "[WARNING] SID not found for group " . $gid;
    }

    $ldapResponse = $ldap->modify($groupDn, replace => $attrs);
    if($ldapResponse->is_error) {
	warn "[ERROR] failed to update $groupDn SAM entry\n";
	$errors++
    }
    
}


#
# import winbind idmap cache
#
system(qq(/usr/bin/net idmap dump ${sourceDir}/var/lib/samba/winbindd_idmap.tdb | /usr/bin/net idmap restore));
if($? != 0) {
    warn "[ERROR] failed to restore idmap\n";
    $errors++;
}

exit($errors > 0 ? 1 : 0);


#
# Move SID record from source secrets.tdb to current secrets.tdb and
# return its value.
#
sub importDomainSid($$)
{
    my $sid = '';
    my $domainName = shift;
    my $sourceTdb = shift;
    my $oldMask = umask 077;
    my $secretsTdb = '/var/lib/samba/private/secrets.tdb';

    my $tmpTdb = File::Temp::tmpnam();

    File::Copy::copy($sourceTdb, $tmpTdb) or die("Could not copy secrets.tdb");

    umask $oldMask;

    # Remove record, if exists
    system(qq(/usr/bin/tdbtool '${secretsTdb}' delete 'SECRETS/SID/${domainName}' &>/dev/null));
    # Copy the SID record in our database:
    system(qq(/usr/bin/tdbtool '${tmpTdb}' move 'SECRETS/SID/${domainName}' '${secretsTdb}' &>/dev/null));
    if($? != 0) {
	warn "[ERROR] Could not import domain $domainName SID from $sourceTdb ($tmpTdb): $!\n";
	return '';
    }

    unlink $tmpTdb;

    open(FH, '-|', '/usr/bin/net getdomainsid') or return '';
    while(<FH>) {
	chomp;
	if(/^SID for domain $domainName is: (S-.*)$/) {
	    $sid = $1;
	    last;
	}
    }
    close(FH);
    return $sid;
}


#
# calculate group name => rid association
#
sub parseGroupMap($$)
{

    my $domainSid = shift;
    my $groupMappingFile = shift;

    my %h = ();

    open(my $LH, '-|', qq(/usr/bin/ldb3search -H tdb://$groupMappingFile -b domain=$domainSid)) or die("[ERROR] Could not read group mappings: $!\n");

    my $ldif = Net::LDAP::LDIF->new($LH, 'r', onerror => 'die');

    while( ! $ldif->eof()) {
	my $entry = $ldif->read_entry();

	if( ! $entry) {
	    warn "[WARNING] an LDIF read_entry() call failed!\n";
	    next;
	}

	my $group = getgrgid($entry->get_value('gidNumber'));
	
	my $dn = $entry->dn();

	$dn =~ /^rid=(\d+),domain=${domainSid}$/;

	if(defined $group && defined $1) {
	    $h{$group->name} = $1;
	}
    }

    close($LH);   
    return %h;
}

#
# obtain user's password hash from smbpasswd DB
#
sub parseSmbPasswd($)
{
    my $dumpFileName = shift;
    open(FH, '<', $dumpFileName) or die("Could not open $dumpFileName!");
    my %db = ();

    while(<FH>) {
	my($uname, $rid, $f1, $nthash, $extra) = split(':', $_, 5);

	my $data = { rid => $rid, password => $nthash };

	# Insert keys in upper/lower/mixed case:
	$db{$uname} = $data;
	$db{lc($uname)} = $data;
	$db{uc($uname)} = $data;
    }

    close(FH);
    return %db;
}
